code:
    import re
    from semantix.utils import ast
    from semantix.caos import types as caos_types
    from semantix.caos.caosql.ast import *
    from semantix.caos.caosql.parser.errors import CaosQLSyntaxError


query                           -> set_query:
                                        return kids[0]
;

set_query                       -> single_set_query:
                                        return kids[0]
                                 | sequence:
                                        return kids[0]
;

sequence                        -> '(' single_set_query (',' single_set_query)* ')':
                                        elements = [kids[1]] + [k[1] for k in kids[2]]
                                        return SequenceNode(elements=elements)
;

single_set_query                -> union_expr:
                                        return kids[0]
                                 | select_query:
                                        return kids[0]
;

union_expr                      -> intersect_expr:
                                        return kids[0]
                                 | union_expr 'UNION' intersect_expr:
                                        return BinOpNode(op='union', left=kids[0], right=kids[2])
;

intersect_expr                  -> additive_expr:
                                        return kids[0]
                                 | intersect_expr intersect_op additive_expr:
                                        return BinOpNode(op=kids[1], left=kids[0], right=kids[2])
;

intersect_op                    -> 'INTERSECT' | 'EXCEPT'
;

primary_query                   -> path_expr:
                                        return kids[0]
                                 | value_query:
                                        return kids[0]
                                 | '(' query ')':
                                        return kids[1]
;

value_query                     -> '*' var
                                 | constant:
                                        return kids[0]
                                 | 'pathof' '(' path_var ')'
                                 | function_name '(' arg_list ')':
                                        return FunctionCallNode(func=kids[0], args=kids[2])
;

additive_expr                   -> multiplicative_expr:
                                        return kids[0]
                                 | additive_expr add_op multiplicative_expr:
                                        return BinOpNode(op=kids[1], left=kids[0], right=kids[2])
;

add_op                          -> '+':
                                        return ast.ops.ADD
                                 | '-':
                                        return ast.ops.SUB
;

multiplicative_expr             -> primary_query:
                                        return kids[0]
                                 | multiplicative_expr mul_op primary_query:
                                        return BinOpNode(op=kids[1], left=kids[0], right=kids[2])
;

mul_op                          -> '*':
                                        return ast.ops.MUL
                                 | '/':
                                        return ast.ops.DIV
                                 | 'mod':
                                        return ast.ops.MOD
;

arg_list                        -> query (',' query )* :
                                        return [kids[0]] + [k[1] for k in kids[1]]
;

select_query                    -> (USING select_nsdecl (',' select_nsdecl)*)?
                                   SELECT (DISTINCT)? select_expr (',' select_expr)*
                                   (WHERE predicate)?
                                   (ORDER BY orderby_expr (',' orderby_expr)*)?
                                   (OFFSET number_constant)?
                                   (LIMIT number_constant)?:

                                        node = SelectQueryNode()

                                        if kids[0]:
                                            node.namespaces = [kids[0][1]] + [k[1] for k in kids[0][2]]

                                        node.distinct = kids[2] is not None
                                        node.targets = [kids[3]] + [k[1] for k in kids[4]]

                                        if kids[5] is not None:
                                            node.where = kids[5][1]

                                        if kids[6] is not None:
                                            node.orderby = [kids[6][2]] + [k[1] for k in kids[6][3]]

                                        if kids[7] is not None:
                                            node.offset = kids[7][1]

                                        if kids[8] is not None:
                                            node.limit = kids[8][1]

                                        return node
;

select_nsdecl                   -> nsname (AS select_identifier)?:
                                        node = NamespaceDeclarationNode()
                                        node.namespace = kids[0]
                                        if kids[1] is not None:
                                            node.alias = kids[1][1]
                                        return node
;
nsname                          -> IDENTIFIER ('.' IDENTIFIER)*:
                                        return '.'.join([kids[0]] + [k[1] for k in kids[1]])
;

select_expr                     -> primary_query (AS select_identifier)?:
                                        alias = kids[1][1] if kids[1] is not None else None
                                        return SelectExprNode(expr=kids[0], alias=alias)
;

select_identifier               -> IDENTIFIER:
                                        return kids[0]
;

predicate                       -> or_predicate:
                                        return kids[0]
;

or_predicate                    -> and_predicate:
                                        return kids[0]
                                 | or_predicate OR and_predicate:
                                        return BinOpNode(op=ast.ops.OR, left=kids[0], right=kids[2])
;

and_predicate                   -> neg_predicate:
                                        return kids[0]
                                 | and_predicate AND neg_predicate:
                                        return BinOpNode(op=ast.ops.AND, left=kids[0], right=kids[2])
;

neg_predicate                   -> simple_predicate:
                                        return kids[0]
                                 | NOT simple_predicate:
                                        return UnaryOpNode(op=ast.ops.NOT, operand=kids[1])
;

simple_predicate                -> primary_query meta_op opt_fq_graph_name:
                                        return BinOpNode(op=kids[1], left=kids[0], right=kids[2])
                                 | primary_query meta_op quantifier opt_fq_graph_name_set:
                                        return BinOpNode(op=kids[1], left=kids[0], right=kids[2])
                                 | primary_query comp_op primary_query:
                                        return BinOpNode(op=kids[1], left=kids[0], right=kids[2])
                                 | path_expr:
                                        return ExistsPredicateNode(expr=kids[0])
                                 | EXISTS '(' set_query ')':
                                        return ExistsPredicateNode(expr=kids[2])
                                 | EXISTS var IN safe_set_query ':' predicate
                                 | FOR ALL var IN safe_set_query ':' predicate
                                 | primary_query IN safe_set_query:
                                        return BinOpNode(op='in', left=kids[0], right=kids[2])
                                 | primary_query comp_op quantifier safe_set_query
                                 | boolean_constant:
                                        return kids[0]
                                 | '(' predicate ')':
                                        return kids[1]
;

safe_set_query                  -> sequence:
                                        return kids[0]
                                 | path_expr:
                                        return kids[0]
;

meta_op                         -> IS:
                                        return ast.ops.IS
                                 | IS NOT:
                                        return ast.ops.IS_NOT
;

comp_op                         -> '<':
                                        return ast.ops.LT
                                 | '<=':
                                        return ast.ops.LE
                                 | '!=':
                                        return ast.ops.NE
                                 | '=':
                                        return ast.ops.EQ
                                 | '>=':
                                        return ast.ops.GE
                                 | '>':
                                        return ast.ops.GT
;

quantifier                      -> SOME | ANY | ALL
;

number_constant                 -> NULL:
                                        return ConstantNode(value=None)
                                 | NUMBER:
                                        if '.' in kids[0]:
                                            value = float(kids[0])
                                        else:
                                            value = int(kids[0])
                                        return ConstantNode(value=value)
                                 | '$' NUMBER:
                                        return ConstantNode(value=None, index=int(kids[1]))
                                 | '$' IDENTIFIER:
                                        return ConstantNode(value=None, index=str(kids[1]))
;

constant                        -> number_constant:
                                        return kids[0]
                                 | LITERAL:
                                        return ConstantNode(value=kids[0].strip('"\''))
                                 | boolean_constant:
                                        return kids[0]
;

boolean_constant                -> TRUE:
                                        return ConstantNode(value=True)
                                 | FALSE:
                                        return ConstantNode(value=False)
;

orderby_expr                    -> path_expr sort_direction?:
                                        return SortExprNode(path=kids[0], direction=kids[1])
;

sort_direction                  -> ASC:
                                        return kids[0]
                                 | DESC:
                                        return kids[0]
;

path_expr                       -> gpe_path:
                                        return kids[0]
;

gpe_path                        -> gpe_path_simple:
                                        return PathNode(steps=kids[0])
                                 | gpe_path '|' gpe_path_simple:
                                        return PathDisjunctionNode(left=kids[0], right=kids[2])
;

gpe_path_simple                 -> path_start gpe_subpath?:
                                        ret = [kids[0]]
                                        if kids[1] is not None:
                                            ret += kids[1]

                                        return ret
;

gpe_subpath                     -> gpe_subpath_no_parens:
                                        return kids[0]
                                 | gpe_subpath_with_parens:
                                        return kids[0]
;

gpe_subpath_with_parens         -> '(' gpe_subpath_no_parens ')':
                                        return kids[1]
                                 | '(' gpe_subpath_with_parens ')':
                                        return kids[1]
;

path_start                      -> label_expr ('@' path_var)? ('{' var '}')?:
                                        if kids[2] is not None:
                                            path = PathNode(steps=[kids[0]])
                                            path.var = kids[2][1]
                                            return path
                                        else:
                                            return kids[0]
;

gpe_subpath_no_parens           -> gpe_path_step+:
                                        return kids[0]
;

gpe_path_step                   -> gpe_path_step_simple ('@' path_var)? ('{' var '}')?:
                                        path = kids[0]
                                        if kids[2] is not None:
                                            if not isinstance(path, PathNode):
                                                path = PathNode(steps=[path])
                                            path.var = kids[2][1]

                                        return path
;

gpe_path_step_simple            -> gpe_subpath_with_parens (regexp_op)?:
                                        quantifier = kids[1][0][0] if kids[1] is not None else None
                                        return PathNode(steps=kids[0], quantifier=quantifier)
                                 | link_expr:
                                        return kids[0]
;

link_expr                       -> '.' link_spec:
                                        return LinkExprNode(expr=kids[1])
;

link_spec                       -> '[' or_link_expr ']':
                                        return kids[1]
                                 | link_label_expr:
                                        return kids[0]
;

or_link_expr                    -> and_link_expr:
                                        return kids[0]
                                 | or_link_expr OR and_link_expr:
                                        return BinOpNode(op=ast.ops.OR, left=kids[0], right=kids[2])
;

and_link_expr                   -> neg_link_expr:
                                        return kids[0]
                                 | and_link_expr AND neg_link_expr:
                                        return BinOpNode(op=ast.ops.AND, left=kids[0], right=kids[2])
;

neg_link_expr                   -> simple_link_expr:
                                        return kids[0]
                                 | NOT simple_link_expr:
                                        return UnaryOpNode(op=ast.ops.NOT, operand=kids[1])
;

simple_link_expr                -> link_label_expr:
                                        return kids[0]
                                 | '(' or_link_expr ')':
                                        return kids[1]
;

opt_fq_graph_name_set           -> '(' opt_fq_graph_name (',' opt_fq_graph_name)* ')':
                                        elements = [kids[1]] + [k[1] for k in kids[2]]
                                        return SequenceNode(elements=elements)
;

opt_fq_graph_name               -> (nsname ':')? IDENTIFIER:
                                        if kids[0]:
                                            grname = PrototypeRefNode(name=kids[1], module=kids[0][0])
                                        else:
                                            grname = PrototypeRefNode(name=kids[1])
                                        return grname
;

graph_name                      -> LABEL_EXPR:
                                        return kids[0]
                                 | IDENTIFIER:
                                        return kids[0]
;

direction                       -> '<>':
                                        return caos_types.AnyDirection
                                 | '>':
                                        return caos_types.OutboundDirection
                                 | '<':
                                        return caos_types.InboundDirection
;

link_label_expr                 -> direction? label_expr:
                                        return LinkNode(name=kids[1].expr, namespace=kids[1].namespace,
                                                        direction=kids[0])
;

label_expr                      -> '%':
                                        return PathStepNode(expr='%')
                                 | (nsname ':')? graph_name:
                                        node = PathStepNode(expr=kids[1])
                                        if kids[0]:
                                            node.namespace = kids[0][0]
                                        return node
;

regexp_op                       -> '*' | '+' | '?'
;

function_name                   -> IDENTIFIER:
                                        return kids[0]
;

var                             -> IDENTIFIER:
                                        return VarNode(name=kids[0])
;

path_var                        -> IDENTIFIER:
                                        return PathVarNode(name=kids[0])
;
