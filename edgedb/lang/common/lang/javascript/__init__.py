##
# Copyright (c) 2012, 2013 Sprymix Inc.
# All rights reserved.
#
# See LICENSE for details.
##


import re
import os
import collections
import itertools
import logging
import importlib
import types
import sys
import zlib

from metamagic.utils.datastructures import OrderedSet
from metamagic.utils import resource, abc
from metamagic.utils.lang import meta as lang_meta, loader as lang_loader
from metamagic.utils.lang.import_ import module, loader, utils as imp_utils


class BaseJavaScriptModule(module.Module):
    pass


class CompiledJavascriptModule(BaseJavaScriptModule, resource.VirtualFile):
    '''A minimized JS sources, usually contains many compressed and/or
    optimized JS modules and their hooks products.

    Used in 'metamagic.utils.resource.publish'
    '''

    def __init__(self, source, name, pubname):
        BaseJavaScriptModule.__init__(self, name)
        resource.VirtualFile.__init__(self, source, pubname)


class JavaScriptModule(BaseJavaScriptModule, resource.File):
    """Whenever you import a javascript file, the resulting module
    will be a subclass of this class"""

    def __init__(self, path, name):
        BaseJavaScriptModule.__init__(self, name)
        self.__sx_imports__ = []
        public_path = name + '.js'
        resource.File.__init__(self, path, public_path=public_path)


class BaseVirtualJavaScriptResource(BaseJavaScriptModule, resource.VirtualFile):
    def __init__(self, source, name):
        self.__sx_imports__ = []
        BaseJavaScriptModule.__init__(self, name)
        resource.VirtualFile.__init__(self, source, name + '.js')


class VirtualJavaScriptResource(BaseVirtualJavaScriptResource):
    def __sx_resource_get_source__(self):
        source = super().__sx_resource_get_source__()
        head = '// !autogenerated!\n_sx_module({!r}, function($module) {{\n"use strict";\n'
        head = head.format(self.__name__)
        source = head.encode('utf-8') + source
        source += '\n});\n'.encode('utf-8')
        return source


class JavaScriptRuntimeDerivative(VirtualJavaScriptResource, lang_meta.RuntimeDerivative):
    def __init__(self, source, name):
        VirtualJavaScriptResource.__init__(self, source, name)
        lang_meta.RuntimeDerivative.__init__(self)


ParsedImport = collections.namedtuple('ParsedImport', 'name, frm, weak')


class _MetamagicImportsHook:
    import_re = re.compile(r'''
        ^(\s*)//(
            \s*(%import|%from)\s+
                (?P<name>.+?)
                (
                    \s+import\s+
                    (?P<fromlist>[^\n]+)
                )?
            )
        \s*$
    ''', re.X | re.M)

    @classmethod
    def parse(cls, source):
        imports = []

        if '%import' in source or '%from' in source:
            match = cls.import_re.search(source)
            while match is not None:
                name = match.group('name').strip()
                fromlist = match.group('fromlist')

                if fromlist is None:
                    for nm in name.split(','):
                        imports.append(ParsedImport(nm.strip(), None, False))
                else:
                    if ',' in name:
                        raise RuntimeError('invalid import statement: "%from {} import {}"'. \
                                           format(name, fromlist))

                    fromlist = (frm.strip() for frm in fromlist.split(','))
                    for frm in fromlist:
                        imports.append(ParsedImport(name, frm, False))

                match = cls.import_re.search(source, match.end())

        return imports

    def __call__(self, loader, modname, imports, source):
        imports.extend(self.parse(source))


class ModuleCache(lang_loader.LangModuleCache):
    def get_magic(self):
        return self._loader.__class__._cache_magic


class JavascriptCodeObject(lang_loader.LanguageCodeObject):
    pass


class JavascriptLoader:
    logger = logging.getLogger('metamagic')

    #: version of cache format
    CACHE_MAGIC_BASE = 3

    # That's the attribute where the actual magic number will be stored.
    # The magic number depends on the 'CACHE_MAGIC_BASE' constant +
    # hash of all registered "import detect" hooks.
    # See "add_import_detect_hook" method for details.
    #
    _cache_magic = CACHE_MAGIC_BASE
    _import_detect_hooks = {}


    @classmethod
    def _recalc_magic(cls):
        # Calculate new magic value, which is a crc32 hash of a special string,
        # which incorporates the CACHE_MAGIC_BASE constant + names of all registered
        # hooks
        #
        hooks_hames = ', '.join(sorted(itertools.chain(cls._import_detect_hooks.keys())))

        hash_key = '{};{}'.format(cls.CACHE_MAGIC_BASE, hooks_hames).encode('latin-1')
        cls._cache_magic = zlib.crc32(hash_key)

    @classmethod
    def add_import_detect_hook(cls, hook):
        hook_name = '{}.{}'.format(hook.__class__.__module__, hook.__class__.__name__)

        if hook_name in cls._import_detect_hooks:
            # Already registered
            #
            return

        cls._import_detect_hooks[hook_name] = hook
        cls._recalc_magic()

    def new_cache(self, modname):
        return ModuleCache(modname, self)

    def cache_path_from_source_path(self, source_path):
        return imp_utils.cache_from_source(source_path, cache_ext='.js')


class Loader(JavascriptLoader, lang_loader.LanguageSourceFileLoader):
    def new_module(self, fullname):
        return JavaScriptModule(self.path, fullname)


class BufferLoader(JavascriptLoader, lang_loader.LanguageSourceBufferLoader):
    def new_module(self, fullname):
        return VirtualJavaScriptResource(None, fullname)


# XXX Do this implicitly?
Loader.add_import_detect_hook(_MetamagicImportsHook())


class Language(lang_meta.Language):
    file_extensions = ('js',)
    loader = Loader

    @classmethod
    def load_code(cls, stream, context):
        modname = context.module.__name__
        loader = sys.modules[modname].__loader__

        if not len(loader._import_detect_hooks):
            # No import hooks?  We can't find any imports then.
            #
            return JavascriptCodeObject((), ())

        source = stream.read().decode()

        # If any imports detect hooks are registered - process the source.
        #
        raw_imports = []

        #if len(loader._import_detect_hooks):
        #    loader.logger.debug('import: {}: parsing javascript'.format(modname))

        for hook in loader._import_detect_hooks.values():
            hook(loader, modname, raw_imports, source)

        if not len(raw_imports):
            # Source was analyzed and no imports found.
            #
            return JavascriptCodeObject((), ())

        is_package = loader.is_package(modname)

        imports = OrderedSet()
        runtime_imports = OrderedSet()

        for imp in raw_imports:
            if imp.frm is None:
                name = imp.name
            else:
                # Here we have to unwind any relative imports, for instance:
                # 'from .. import foo' in 'a.b.c' module should be transformed
                # to 'import a.foo'

                imp_package = imp.name
                if imp_package.startswith('.'):
                    mod_package = modname

                    if is_package:
                        # Import from __init__
                        #
                        imp_package = imp_package[1:]

                    while imp_package.startswith('.'):
                        imp_package = imp_package[1:]
                        mod_package = mod_package.rpartition('.')[0]

                    if imp_package:
                        imp_package = mod_package + '.' + imp_package
                    else:
                        imp_package = mod_package

                name = imp_package + '.' + imp.frm

            if imp.weak:
                runtime_imports.add(name)
            else:
                imports.add(name)

        return JavascriptCodeObject(None, imports=tuple(imports),
                                          runtime_imports=tuple(runtime_imports))

    @classmethod
    def execute_code(cls, code, context):
        modname = context.module.__name__
        module = sys.modules[modname]

        target_runtimes = cls.get_compatible_runtimes(module)

        for imp_name in itertools.chain(code.imports, code.runtime_imports):
            mod = importlib.import_module(imp_name)
            mod.__loader__.load_module_for_runtimes(imp_name, target_runtimes)

        return []


class JavaScriptRuntime(lang_meta.LanguageRuntime, languages=Language, default=True):
    @classmethod
    def new_derivative(cls, mod):
        _sx_module = importlib.import_module('metamagic.utils.lang.javascript.module')
        res = JavaScriptRuntimeDerivative(None, cls.get_derivative_mod_name(mod))
        res.__sx_imports__ += (_sx_module.__name__,)
        return res

    @classmethod
    def get_adapters(cls, value):
        for runtime in [r for r in cls.__mro__ if issubclass(r, JavaScriptRuntime)]:
            adapters = lang_meta.LanguageRuntimeAdapterMeta.get_adapter(value, runtime=runtime)
            if adapters:
                return adapters


class JavaScriptRuntimeAdapterMeta(lang_meta.LanguageRuntimeAdapterMeta):
    def __new__(mcls, name, bases, clsdict, *, runtime=JavaScriptRuntime, adapts=None, pure=True,
                                                                                       **kwargs):
        return super().__new__(mcls, name, bases, clsdict, runtime=runtime, adapts=adapts,
                                                                            pure=pure, **kwargs)

    def __init__(cls, name, bases, clsdict, *, runtime=JavaScriptRuntime, adapts=None, pure=True,
                                                                                       **kwargs):
        return super().__init__(name, bases, clsdict, runtime=runtime, adapts=adapts, pure=pure,
                                                                                      **kwargs)


class JavaScriptRuntimeAdapter(metaclass=JavaScriptRuntimeAdapterMeta):
    def __init__(self, module, derivative, attr_name=None, attr_value=None):
        self.module = module
        self.derivative = derivative
        self.attr_name = attr_name
        self.attr_value = attr_value
