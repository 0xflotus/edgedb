##
# Copyright (c) 2008-2011 Sprymix Inc.
# All rights reserved.
#
# See LICENSE for details.
##


code:
    # from metamagic.utils.lang.javascript.parser.keywords import js_keywords
    import pyggy

    def advance_line_col(this):
        this.start = (this.line, this.col)
        this.col += len(this.value)
        this.end = (this.line, this.col)

    # also need to set up the following attributes of the lexer:
    #  - no_newline
    #  - regexp_possible
    #  - line (starting line counter)
    #  - col (starting col counter)

    pyggy.lexer.lexer.multiline_strings = False
    pyggy.lexer.lexer.regexp_possible = True
    pyggy.lexer.lexer.swallow_line_cont = False
    pyggy.lexer.lexer.line = 1
    pyggy.lexer.lexer.col = 1
    pyggy.lexer.lexer.start = pyggy.lexer.lexer.end = (1,1)

definitions:
    # eventually we might also want <VT> <FF> <NBSP>
    #whitespace          "[\t ]"
    lineterminator      "[\r\n]|\r\n"

    # comment components
    scomment_notterm  "[^\r\n]"
    mcomment_notstar_notslash   "[^\*/\r\n]"

    # operators
    operator_notslash   "<|>|<=|>=|==|!=|===|!==|\+|-|\*|%|\+\+|--|<<|>>|>>>|&|\||\^|!|~|&&|\|\||\?|=|\+=|-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^="
    operator_slash      "/|/="

    # identifier
    id  "[$_A-Za-z]+[$_A-Za-z0-9]*"

    # numbers
    decdigit        "[0-9]"
    decdigitnonzero "[1-9]"
    hexdigit        "[0-9a-fA-F]"
    intpart         "{decdigitnonzero}{decdigit}*|0"
    exppart         "[eE]([\+\-])?{decdigit}*"
    octdigit        "[0-7]"

    # string literals
    doublestringchar    "[^\"\\\r\n]"
    singlestringchar    "[^\'\\\r\n]"
    linecont            "\\{lineterminator}"
    hexescapesequence   "\\x{hexdigit}{hexdigit}"
    uniescapesequence   "\\u{hexdigit}{hexdigit}{hexdigit}{hexdigit}"
    octescapesequence   "\\({octdigit}|{octdigit}{octdigit}|[0-3]{octdigit}{octdigit})"
    escapechar          "\\[\'\"\\bnfrtv]"

    # regular expression literals
    regexp_firstchar        "[^\r\n\*\\/\[]"
    regexp_restchar         "[^\r\n\\/\[]"
    regexp_classchar        "[^\r\n\]\\]"
    regexp_backslashchar    "[^\r\n]"

    regexp_backescape       "\\{regexp_backslashchar}"
    regexp_class            "\[({regexp_classchar}|{regexp_backescape})*\]"


INITIAL:

    # whitespace proper
    "\t+":
        self.col = ((self.col - 1)//4 + len(self.value))*4 + 1
    " +":
        self.col += len(self.value)
    "{lineterminator}":
        self.col = 1
        self.line += 1
        #if self.no_newline:
        #    return '#ERR#'

    #
    #
    # special case for preprocessor
    #
    "\\{lineterminator}":
        self.value = '\\'
        advance_line_col(self)
        self.col = 1
        self.line += 1

        if self.swallow_line_cont:
            return
        else:
            return '#ERR#'

    "#(define|error|warning|include|if|ifdef|ifndef|elif|else|endif)|#|##":
        advance_line_col(self)
        return '#ERR#'

    #
    # end of special case for preprocessor
    #
    #

    # comments
    "//":
        self.col += len(self.value)
        self.PUSHSTATE(SINGLELINECOMMENT)
    "/\*":
        self.col += len(self.value)
        self.PUSHSTATE(MULTILINECOMMENT)

# might need to include unary prefix ops here

    "{id}":
        advance_line_col(self)
        return "ID"

    "\"\"\"":
        if not self.multiline_strings:
            return '#ERR#'

        self.string = ""
        self.start = (self.line, self.col)
        self.col += len(self.value)
        self.PUSHSTATE(MULTILINE_DQ)

    "\'\'\'":
        if not self.multiline_strings:
            return '#ERR#'

        self.string = ""
        self.start = (self.line, self.col)
        self.col += len(self.value)
        self.PUSHSTATE(MULTILINE_SQ)

    # string literals
    "\"":
        self.string = ""
        self.start = (self.line, self.col)
        self.col += len(self.value)
        self.PUSHSTATE(DOUBLEQUOTE)

    "\'":
        self.string = ""
        self.start = (self.line, self.col)
        self.col += len(self.value)
        self.PUSHSTATE(SINGLEQUOTE)

    # decimal literals
    "{intpart}(\.{decdigit}*)?{exppart}?":
        advance_line_col(self)
        self.value = int(self.value) if self.value.isdecimal() else float(self.value)
        return "NUMBER"
    "\.{decdigit}+{exppart}?":
        advance_line_col(self)
        self.value = float(self.value)
        return "NUMBER"

    # hex literals
    "0x{hexdigit}+":
        advance_line_col(self)
        self.value = int(self.value, 16)
        return "NUMBER"

    # octal literals
    "0{octdigit}+":
        advance_line_col(self)
        self.value = int(self.value, 8)
        return "NUMBER"

    # operators, separators, etc.
    "{operator_notslash}":
        advance_line_col(self)
        return "OP"

    "\{|\}|\[|\]|\(|\)|\.":
        advance_line_col(self)
        return "OP"

    ";":
        advance_line_col(self)
        return "SEMICOLON"

    ":":
        advance_line_col(self)
        return "COLON"

    ",":
        advance_line_col(self)
        return "COMMA"

    # '@' is used for decorators in JPlus
    "@":
        advance_line_col(self)
        return "AT"

    "\.\.\.":
        advance_line_col(self)
        return "ELLIPSIS"

    # special handling of '/', '/=' and regexp
    "/[^\*/]":
        if self.regexp_possible:
            self.PUSHBACK(self.value)
            self.PUSHSTATE(REGEXP)
        else:
            nextchar = self.value[-1:]
            if nextchar != '=':
                # bite off the second char if it isn't '='
                self.value = self.value[0]
                self.PUSHBACK(nextchar)
            advance_line_col(self)
            #self.col += len(self.value)
            return "OP"

###### Helper states ######

SINGLELINECOMMENT:
    "{scomment_notterm}*":
        self.col += len(self.value)
        return #"COMMENT"
    "{lineterminator}":
        self.col = 1
        self.line += 1
        self.POPSTATE()
        #if self.no_newline:
        #    return '#ERR#'


MULTILINECOMMENT:
    "{lineterminator}":
        self.col = 1
        self.line += 1
        #if self.no_newline:
        #    return '#ERR#'

    "{mcomment_notstar_notslash}+":
        self.col += len(self.value)
    "\*+":
        self.col += len(self.value)
    "/+":
        self.col += len(self.value)
    "\*+/":
        self.col += len(self.value)
        self.POPSTATE()


MULTILINE_SQ:
    "{lineterminator}":
        self.col = 1
        self.line += 1
        self.string += self.value

    "\'\'\'":
        self.POPSTATE()
        self.col += len(self.value)
        self.value = self.string
        self.end = (self.line, self.col)
        return "STRING"

    "\'":
        self.col += len(self.value)
        self.string += self.value

    "[^\'\r\n]*":
        self.col += len(self.value)
        self.string += self.value


MULTILINE_DQ:
    "{lineterminator}":
        self.col = 1
        self.line += 1
        self.string += self.value

    "\"\"\"":
        self.POPSTATE()
        self.col += len(self.value)
        self.value = self.string
        self.end = (self.line, self.col)
        return "STRING"

    "\"":
        self.col += len(self.value)
        self.string += self.value

    "[^\"\r\n]*":
        self.col += len(self.value)
        self.string += self.value


DOUBLEQUOTE:
    "{doublestringchar}+":
        self.string += self.value
        self.col += len(self.value)
    "{linecont}":
        # just consume it and keep reading the string
        self.col = 1
        self.line += 1
    "{hexescapesequence}|{uniescapesequence}|{octescapesequence}|{escapechar}":
        # convert the escape sequence
        self.string += bytes(self.value, "utf-8").decode("unicode_escape")
        self.col += len(self.value)
    "\\":
        # some non-escape character after "\", just consume "\"
        self.col += len(self.value)
    "\"":
        self.POPSTATE()
        self.col += len(self.value)
        self.value = self.string
        self.end = (self.line, self.col)
        return "STRING"

SINGLEQUOTE:
    "{singlestringchar}+":
        self.string += self.value
        self.col += len(self.value)
    "{linecont}":
        # just consume it and keep reading the string
        self.col = 1
        self.line += 1
    "{hexescapesequence}|{uniescapesequence}|{octescapesequence}|{escapechar}":
        # convert the escape sequence
        self.string += bytes(self.value, "utf-8").decode("unicode_escape")
        self.col += len(self.value)
    "\\":
        # some non-escape character after "\", just consume "\"
        self.col += len(self.value)
    "\'":
        self.POPSTATE()
        self.col += len(self.value)
        self.value = self.string
        self.end = (self.line, self.col)
        return "STRING"

REGEXP:
    # regexp literals
    "/({regexp_firstchar}|{regexp_class}|{regexp_backescape})({regexp_restchar}|{regexp_class}|{regexp_backescape})*/[$_A-Za-z0-9]*":
        self.POPSTATE()
        advance_line_col(self)
        return "REGEXP"
