##
# Copyright (c) 2008-2011 Sprymix Inc.
# All rights reserved.
#
# See LICENSE for details.
##


code:
    from semantix.utils.lang.javascript.parser.keywords import js_keywords

    # initialize the line counter to 1
    linenumber = 1

    # can we expect a regexp literal next or not
    regexp_possible = True

definitions:
    # eventually we might also want <VT> <FF> <NBSP>
    whitespace          "[\t ]"
    lineterminator      "[\r\n]|\r\n"

    # comment components
    scomment_notterm  "[^\r\n]"
    mcomment_notstar_notslash   "[^\*/\r\n]"
#    mcomment_notstar            "[^\*\r\n]"

    # operators
    operator_notslash                   "<|>|<=|>=|==|!=|===|!==|\+|-|\*|%|\+\+|--|<<|>>|>>>|&|\||\^|!|~|&&|\|\||\?|=|\+=|-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^="
    operator_slash                      "/|/="

    # identifier
    id  "[$_A-Za-z]+[$_A-Za-z0-9]*"

    # numbers
    decdigit        "[0-9]"
    decdigitnonzero "[1-9]"
    hexdigit        "[0-9a-fA-F]"
    octdigit        "[0-7]"
    intpart         "{decdigitnonzero}{decdigit}*|0"
    exppart         "[eE]([\+\-])?{decdigit}*"

    # string literals
    doublestringchar    "[^\"\\\r\n]"
    singlestringchar    "[^\'\\\r\n]"
    linecont            "\\{lineterminator}"
    hexescapesequence   "\\x{hexdigit}{hexdigit}"
    uniescapesequence   "\\u{hexdigit}{hexdigit}{hexdigit}{hexdigit}"
    octescapesequence   "\\([0-7]|[0-7][0-7]|[0-3][0-7][0-7])"
    escapechar          "\\[\'\"\\bnfrtv]"

    # regular expression literals
    regexp_firstchar        "[^\r\n\*\\/\[]"
    regexp_restchar         "[^\r\n\\/\[]"
    regexp_classchar        "[^\r\n\]\\]"
    regexp_backslashchar    "[^\r\n]"

INITIAL:
    # whitespace
    "{whitespace}+":
        return #"WSPACE"
    "{lineterminator}":
        global linenumber
        linenumber+=1

    # comments
#    "//":
#        self.PUSHSTATE(SINGLELINECOMMENT)
    "/\*+\*/":
        return # empty multiline comment, just consume it
#    "/\*+":
#        self.PUSHSTATE(MULTILINECOMMENT)

    # operators, separators, etc.
    "{operator_notslash}":
        global regexp_possible
        regexp_possible = True
        return self.value
    # handling /*, //, /, /=, and regexp literals
    "/.":
        global regexp_possible
        nextchar = self.value[-1:]

        print("accepted -> '%s'" % self.value)
        print("nextchar -> '%s'" % nextchar)

        if nextchar == '/':
            # single line comment
            self.PUSHSTATE(SINGLELINECOMMENT)
        elif nextchar == '*':
            # multi-line comment
            self.PUSHSTATE(MULTILINECOMMENT)
        elif regexp_possible:
            # process as regexp literal
            self.string = '/'
            self.PUSHBACK(nextchar)
            self.PUSHSTATE(REGEXP)
        else:
            print("not comment or regexp")
            # this is '/' or '/='
            regexp_possible = True
            if nextchar != '=':
                # bite off the second char if it isn't '='
                self.value = self.value[0]
                self.PUSHBACK(nextchar)
            return self.value
    "\{":
        global regexp_possible
        regexp_possible = True
        return "LCBRACKET"
    "\}":
        global regexp_possible
        regexp_possible = True
        return "RCBRACKET"
    "\[":
        global regexp_possible
        regexp_possible = True
        return "LSBRACKET"
    "\]":
        global regexp_possible
        regexp_possible = False
        return "RSBRACKET"
    "\(":
        global regexp_possible
        regexp_possible = True
        return "LPAREN"
    "\)":
        global regexp_possible
        regexp_possible = False
        return "RPAREN"
    "\.":
        global regexp_possible
        # this is not a dot in the numeric literal
        # so we need to push back the last char
        #self.PUSHBACK(self.value[-1:])
        regexp_possible = False
        return "DOT"
    ";":
        global regexp_possible
        regexp_possible = True
        return "SEMICOLON"
    ":":
        global regexp_possible
        regexp_possible = True
        return "COLON"
    ",":
        global regexp_possible
        regexp_possible = True
        return "COMMA"

    # identifiers, reserved words
    "{id}":
        global regexp_possible
        kw = js_keywords.get(self.value)
        if kw:
            regexp_possible = True
            return kw[0]
        else:
            regexp_possible = False
            return 'ID'

    # string literals
    "\"":
        self.string = ""
        self.PUSHSTATE(DOUBLEQUOTE)
    "\'":
        self.string = ""
        self.PUSHSTATE(SINGLEQUOTE)

    # decimal literals
    # need to make sure they aren't spliced with anything weird like letters or "."
    # so we'll need to push one symbol back
    "{intpart}(\.{decdigit}*)?{exppart}?":
        global regexp_possible
        self.value = int(self.value) if self.value.isdecimal() else float(self.value)
        regexp_possible = False
        return "NUMBER"
    "\.{decdigit}+{exppart}?":
        global regexp_possible
        self.value = float(self.value)
        regexp_possible = False
        return "NUMBER"

    # hex literals
    "0x{hexdigit}+":
        global regexp_possible
        self.value = int(self.value, 16)
        regexp_possible = False
        return "NUMBER"

    # octal literals
    "0{octdigit}+":
        global regexp_possible
        self.value = int(self.value, 8)
        regexp_possible = False
        return "NUMBER"


SINGLELINECOMMENT:
    "{scomment_notterm}*":
        return #"COMMENT"
    "{lineterminator}":
        self.POPSTATE()
        global linenumber
        linenumber+=1

MULTILINECOMMENT:
    "{lineterminator}":
        global linenumber
        linenumber+=1
        return #"COMMENT"
    "{mcomment_notstar_notslash}+":
        return #"COMMENT"
    "\*":
        return #"COMMENT"
    "/":
        return #"COMMENT"
    "\**/":
        self.POPSTATE()

DOUBLEQUOTE:
    "{doublestringchar}+":
        self.string += self.value
    "{linecont}":
        # just consume it and keep reading the string
        global linenumber
        linenumber+=1
    "{hexescapesequence}|{uniescapesequence}|{octescapesequence}|{escapechar}":
        # convert the escape sequence
        self.string += bytes(self.value, "utf-8").decode("unicode_escape")
    "\\":
        # some non-escape character after "\", just consume "\"
        return
    "\"":
        global regexp_possible
        self.POPSTATE()
        self.value = self.string
        regexp_possible = False
        return "STRING"

SINGLEQUOTE:
    "{singlestringchar}+":
        self.string += self.value
    "{linecont}":
        # just consume it and keep reading the string
        global linenumber
        linenumber+=1
    "{hexescapesequence}|{uniescapesequence}|{octescapesequence}|{escapechar}":
        # convert the escape sequence
        self.string += bytes(self.value, "utf-8").decode("unicode_escape")
    "\\":
        # some non-escape character after "\", just consume "\"
        return
    "\'":
        global regexp_possible
        self.POPSTATE()
        self.value = self.string
        regexp_possible = False
        return "STRING"

REGEXP:
# process first char, then the rest of the literal, backtrack on errors
    "{regexp_firstchar}":
        self.string += self.value
        # ugly [hack] ! I really kinda mean 'goto'
        # I'm afaraid that if I don't POP the state first I may end up with weird
        # behavior in large programs
        # self.POPSTATE()
        self.PUSHSTATE(REGEXP_MORE)

    "\[":
        self.string += self.value
        # ugly!
        # self.POPSTATE()
        self.PUSHSTATE(REGEXP_CLASS)

    "\\":
        self.string += self.value
        # ugly!
        # self.POPSTATE()
        self.PUSHSTATE(REGEXP_BACKSLASH)

    # error: this isn't a regexp, this is '/' followed by other stuff
    "{lineterminator}|\*|/":
        self.string += self.value
        self.value, rest = self.string[1], self.string[1:]
        self.PUSHBACK(rest)
        self.POPSTATE()

        print("pushing back '%s'" % rest)

        return self.value

REGEXP_MORE:
    "{regexp_restchar}":
        self.string += self.value

    "\[":
        self.string += self.value
        self.PUSHSTATE(REGEXP_CLASS)

    "\\":
        self.string += self.value
        self.PUSHSTATE(REGEXP_BACKSLASH)

    "/[$_A-Za-z0-9]*":
        global regexp_possible
        self.string += self.value
        self.PUSHSTATE(INITIAL)
        self.value = self.string
        regexp_possible = False
        return "REGEXP"

    # error: this isn't a regexp, this is '/' followed by other stuff
    "{lineterminator}":
        global regexp_possible
        self.string += self.value
        self.value, rest = self.string[1], self.string[1:]
        self.PUSHBACK(rest)
        self.PUSHSTATE(INITIAL)

        print("pushing back '%s'" % rest)

        regexp_possible = True
        return self.value

REGEXP_CLASS:
    "{regexp_classchar}":
        self.string += self.value

    "\]":
        self.string += self.value
        self.POPSTATE()

    "\\":
        self.string += self.value
        self.PUSHSTATE(REGEXP_BACKSLASH)

    # error: this isn't a regexp, this is '/' followed by other stuff
    "{lineterminator}":
        global regexp_possible
        self.string += self.value
        self.value, rest = self.string[1], self.string[1:]
        self.PUSHBACK(rest)
        self.PUSHSTATE(INITIAL)

        print("pushing back '%s'" % rest)

        regexp_possible = True
        return self.value

REGEXP_BACKSLASH:
    "{regexp_backslashchar}":
        self.string += self.value
        self.POPSTATE()

    # error: this isn't a regexp, this is '/' followed by other stuff
    "{lineterminator}":
        global regexp_possible
        self.string += self.value
        self.value, rest = self.string[1], self.string[1:]
        self.PUSHBACK(rest)
        self.PUSHSTATE(INITIAL)

        print("pushing back '%s'" % rest)

        regexp_possible = True
        return self.value
