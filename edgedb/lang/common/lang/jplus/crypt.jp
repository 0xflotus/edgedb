/**
 * Copyright (c) 2012-2014 MagicStack Inc.
 * All rights reserved.
 *
 * See LICENSE for details.
 */


export sha1, md5

from metamagic.utils.lang.jplus import byteutils

from javascript import Math


fn hex(n) {
    return (n >> 28 & 0xF).toString(16) +
           (n >> 24 & 0xF).toString(16) +
           (n >> 20 & 0xF).toString(16) +
           (n >> 16 & 0xF).toString(16) +
           (n >> 12 & 0xF).toString(16) +
           (n >> 8 & 0xF).toString(16) +
           (n >> 4 & 0xF).toString(16) +
           (n & 0xF).toString(16)
}

pads = [[0x80]]
maxlen = 0xFFFFFFFF / 8

for i = 1; i < 70; i++ {
    pads.push(pads[i - 1].concat([0]))
}


fn sha1(msg) {
    // Algorithm from http://en.wikipedia.org/wiki/SHA-1

    if msg.length > maxlen {
        throw new ValueError('unable to calculate sha1: message too long')
    }

    if isinstance(msg, String) {
        msg = byteutils.toBytes(msg)
    }

    h0 = 0x67452301
    h1 = 0xEFCDAB89
    h2 = 0x98BADCFE
    h3 = 0x10325476
    h4 = 0xC3D2E1F0
    len = msg.length
    w = new Array(80)

    // pad with zeroes to be congruent to 56 (448 bits, mod 512)
    // + 4 bytes for zeroes, as part of 64bit length (we append
    // only 32 bits later)
    msg.push.apply(msg, pads[((55 - len) % 64 + 64) % 64 + 4])

    len = len << 3 // length in bits -- len * 8
    // append 32 bit length !! big-endian !!
    msg.push((len >> 24) & 0xFF, (len >> 16) & 0xFF,
             (len >> 8) & 0xFF, len & 0xFF)

    len = msg.length

    for n = 0; n < len; n += 64 {
        a = h0
        b = h1
        c = h2
        d = h3
        e = h4

        i = 0
        k = n
        for j = 0; j < 16; j += 1 {
            k = n + i

            w[j] = (msg[k] << 24) | (msg[k + 1] << 16) |
                   (msg[k + 2] << 8) | (msg[k + 3] << 0)

            i += 4
        }

        for i = 16; i < 80; i++ {
            k = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]
            w[i] = (k << 1) | (k >>> 31)
        }

        for i = 0; i < 20; i++ {
            tmp = ((a << 5) | (a >>> 27)) + e + w[i] + 0x5A827999 +
                                            ((b & c) | (~b & d))
            e = d
            d = c
            c = (b << 30) | (b >>> 2)
            b = a
            a = tmp
        }

        for i = 20; i < 40; i++ {
            tmp = ((a << 5) | (a >>> 27)) + e  + w[i] + 0x6ED9EBA1 +
                                            (b ^ c ^ d)
            e = d
            d = c
            c = (b << 30) | (b >>> 2)
            b = a
            a = tmp
        }

        for i = 40; i < 60; i++ {
            tmp = ((a << 5) | (a >>> 27)) + e  + w[i] + 0x8F1BBCDC +
                                            ((b & c) | (b & d) | (c & d))
            e = d
            d = c
            c = (b << 30) | (b >>> 2)
            b = a
            a = tmp
        }

        for i = 60; i < 80; i++ {
            tmp = ((a << 5) | (a >>> 27)) + e + w[i] + 0xCA62C1D6 + (b ^ c ^ d)
            e = d
            d = c
            c = (b << 30) | (b >>> 2)
            b = a
            a = tmp
        }

        h0 = (h0 + a) << 0
        h1 = (h1 + b) << 0
        h2 = (h2 + c) << 0
        h3 = (h3 + d) << 0
        h4 = (h4 + e) << 0
    }

    return hex(h0) + hex(h1) + hex(h2) + hex(h3) + hex(h4)
}


S = [ 7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
      5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
      4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
      6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21 ]

K = [Math.floor(Math.abs(Math.sin(i + 1)) * 0x100000000) for i = 0; i < 64; i++]


fn leftrotate(x, c) {
    return (x << c) | (x >>> (32 - c))
}


fn reverse(num) {
    res = ((num >>> 24) & 0xFF)
    res += ((num >>> 16) & 0xFF) << 8
    res += ((num >>> 8) & 0xFF) << 16
    res += (num & 0xFF) << 24
    return res
}


fn md5(msg) {
        // Algorithm from http://en.wikipedia.org/wiki/MD5

    if msg.length > maxlen {
        throw new ValueError('unable to calculate md5: message too long')
    }

    if isinstance(msg, String) {
        msg = byteutils.toBytes(msg)
    }

    a0 = 0x67452301
    b0 = 0xEFCDAB89
    c0 = 0x98BADCFE
    d0 = 0x10325476
    len = msg.length

    m = new Array(16)

    // pad with zeroes to be congruent to 52 (448 bits, mod 512)
    msg.push.apply(msg, pads[((55 - len) % 64 + 64) % 64])

    len = len << 3 // length in bits -- len * 8
    // append 32 bit length !! little-endian !!
    msg.push(len & 0xFF, (len >> 8) & 0xFF,
             (len >> 16) & 0xFF, (len >> 24) & 0xFF,
             0, 0, 0, 0)

    len = msg.length

    for n = 0; n < len; n += 64 {
        i = 0

        for j = 0; j < 16; j++ {
            k = n + i

            // little endian
            m[j] = (msg[k] << 0) | (msg[k + 1] << 8) |
                   (msg[k + 2] << 16) | (msg[k + 3] << 24)

            i += 4
        }

        a = a0
        b = b0
        c = c0
        d = d0

        for i = 0; i < 16; i++ {
            f = (b & c) | ((~b) & d)
            d_temp = d
            d = c
            c = b
            b = (b + leftrotate((a + f + K[i] + m[i]), S[i])) << 0
            a = d_temp
        }

        for i = 16; i < 32; i++ {
            f = (d & b) | ((~d) & c)
            d_temp = d
            d = c
            c = b
            b = (b + leftrotate(a + f + K[i] + m[(5 * i + 1) % 16], S[i])) << 0
            a = d_temp
        }

        for i = 32; i < 48; i++ {
            f = b ^ c ^ d
            d_temp = d
            d = c
            c = b
            b = (b + leftrotate(a + f + K[i] + m[(3 * i + 5) % 16], S[i])) << 0
            a = d_temp
        }

        for i = 48; i < 64; i++ {
            f = c ^ (b | (~d))
            d_temp = d
            d = c
            c = b
            b = (b + leftrotate(a + f + K[i] + m[(7 * i) % 16], S[i])) << 0
            a = d_temp
        }

        a0 = (a + a0) << 0
        b0 = (b + b0) << 0
        c0 = (c + c0) << 0
        d0 = (d + d0) << 0
    }

    return hex(reverse(a0)) + hex(reverse(b0)) +
           hex(reverse(c0)) + hex(reverse(d0))
}
