/*
* Copyright (c) 2013-2014 MagicStack Inc.
* All rights reserved.
*
* See LICENSE for details.
**/


export unhexlify, hexlify, toBytes, fromBytes


hex = '0123456789abcdef'


fn _UTF8Encode(str) {
    if !str {
        return ''
    }
    return unescape(encodeURIComponent(String(str)))
}


fn _UTF8Decode(str) {
    if !str {
        return ''
    }
    return decodeURIComponent(escape(String(str)))
}


fn unhexlify(hex) {
    // equivalent to python's `binascii.unhexlify`

    l = hex.length

    if l % 2 == 1 {
        throw new ValueError('Odd-length string')
    }

    bytes = new Array(l >> 1)

    i = 0
    j = 0

    while i < l {
        bytes[j] = parseInt(hex[i] + hex[i+1], 16)
        i += 2
        j += 1
    }

    return bytes
}


fn hexlify(bytes) {
    l = bytes.length
    res = ''

    for i = 0; i < l; i++ {
        c1 = bytes[i]

        c2 = (c1 & 0xf0) >> 4
        c1 = c1 & 0xf

        res += hex[c2] + hex[c1]
    }

    return res
}


fn toBytes(str) {
    // encodes JS unicode string to utf8, and returns
    // array of bytes

    str = _UTF8Encode(str)
    l = str.length
    res = new Array(l)

    for i = 0; i < l; i++ {
        res[i] = str.charCodeAt(i)
    }

    return res
}


fn fromBytes(msg) {
    str = ''

    l = msg.length

    for i = 0; i < l; i++ {
        str += String.fromCharCode(msg[i])
    }

    return _UTF8Decode(str)
}

