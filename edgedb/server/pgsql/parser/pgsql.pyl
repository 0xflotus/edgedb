##
# Copyright (c) 2008-2010 Sprymix Inc.
# All rights reserved.
#
# See LICENSE for details.
##

#
# Based on scan.l from PostgreSQL 9.0
#


code:
    from semantix.caos.backends.pgsql.parser.error import PgSQLParserError
    from semantix.caos.backends.pgsql.parser.keywords import pg_keywords
    from semantix.caos.backends.pgsql import ast as pgast

definitions:
    space               "[ \t\n\r\f]"
    horiz_space         "[ \t\f]"
    newline             "[\n\r]"
    non_newline         "[^\n\r]"
    comment             "--{non_newline}*"
    whitespace          "{space}+|{comment}"

    special_whitespace      "({space}+|{comment}{newline})"
    horiz_whitespace        "({horiz_space}|{comment})"
    whitespace_with_newline "({horiz_whitespace}*{newline}{special_whitespace}*)"

    quote                   "'"
    quotestop               "{quote}{whitespace}*"
    quotecontinue           "{quote}{whitespace_with_newline}{quote}"
    quotefail               "{quote}{whitespace}*-"


# Bit string
    xbstart                 "[bB]{quote}"
    xbinside                "[^']*"

# Hexadecimal number
    xhstart                 "[xX]{quote}"
    xhinside                "[^']*"

# National character
    xnstart                 "[nN]{quote}"


# Quoted string that allows backslash escapes
    xestart                 "[eE]{quote}"
    xeinside                "[^\\']+"
    xeescape                "[\\][^0-7]"
    xeoctesc                "[\\]([0-7]|([0-7][0-7])|([0-7][0-7][0-7]))"
    xehexesc                "[\\]x([0-9A-Fa-f]|([0-9A-Fa-f][0-9A-Fa-f]))"
    xeunicode               "[\\](u[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]|U[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])"
    xeunicodefail           "[\\]((u|u[0-9A-Fa-f]|u([0-9A-Fa-f][0-9A-Fa-f])|u([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]))|(U|U[0-9A-Fa-f]|U([0-9A-Fa-f][0-9A-Fa-f])|U([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])|U([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])|U([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])|U([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])|U([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])))"


# Extended quote
    xqstart                 "{quote}"
    xqdouble                "{quote}{quote}"
    xqinside                "[^']+"

# $foo$ style quotes ("dollar quoting")
    dolq_start              "[A-Za-z\200-\377_]"
    dolq_cont               "[A-Za-z\200-\377_0-9]"
    dolqdelim               "\$({dolq_start}{dolq_cont}*)?\$"
    dolqfailed              "\${dolq_start}{dolq_cont}*"
    dolqinside              "[^$]+"

# Double quote
    dquote                  "\""
    xdstart                 "{dquote}"
    xdstop                  "{dquote}"
    xddouble                "{dquote}{dquote}"
    xdinside                "[^"]+"

# Unicode escapes
    uescape                 "[uU][eE][sS][cC][aA][pP][eE]{whitespace}*{quote}[^']{quote}"

# error rule to avoid backup
    uescapefail             "(-|[uU][eE][sS][cC][aA][pP][eE]{whitespace}*-|[uU][eE][sS][cC][aA][pP][eE]{whitespace}*{quote}[^']|[uU][eE][sS][cC][aA][pP][eE]{whitespace}*{quote}|[uU][eE][sS][cC][aA][pP][eE]{whitespace}*|[uU][eE][sS][cC][aA][pP]|[uU][eE][sS][cC][aA]|[uU][eE][sS][cC]|[uU][eE][sS]|[uU][eE]|[uU])"

# Quoted identifier with Unicode escapes
    xuistart                "[uU]&{dquote}"
    xuistop1                "{dquote}{whitespace}*{uescapefail}?"
    xuistop2                "{dquote}{whitespace}*{uescape}"

# Quoted string with Unicode escapes
    xusstart                "[uU]&{quote}"
    xusstop1                "{quote}{whitespace}*{uescapefail}?"
    xusstop2                "{quote}{whitespace}*{uescape}"

# error rule to avoid backup
    xufailed                "[uU]&"

    self                    "[,\(\)\[\].;\:\+\-\*\/\%\^\<\>\=]"
    op_chars                "[\~\!\@\#\^\&\|\`\?\+\-\*\/\%\<\>\=]"
    operator                "{op_chars}+"

# C-style comments
    xcstart                 "\/\*{op_chars}*"
    xcstop                  "\*+\/"
    xcinside                "[^*/]+"

    digit                   "[0-9]"
    ident_start             "[A-Za-z\200-\377_]"
    ident_cont              "[A-Za-z\200-\377_0-9\$]"

    identifier              "{ident_start}{ident_cont}*"

    typecast                "::"


    integer                 "{digit}+"
    decimal                 "(({digit}*\.{digit}+)|({digit}+\.{digit}*))"
    decimalfail             "{digit}+\.\."
    real                    "({integer}|{decimal})[Ee][\-\+]?{digit}+"
    realfail1               "({integer}|{decimal})[Ee]"
    realfail2               "({integer}|{decimal})[Ee][\-\+]"

    param                   "\${integer}"

    other                   "."



INITIAL:
    "{whitespace}":
        return

    "{xcstart}":
        self.xcdepth = 0
        self.PUSHSTATE(XC)
        self.PUSHBACK(self.value[2:])

    "{xbstart}":
        self.PUSHSTATE(XB)
        self.string = ''

    "{xhstart}":
        self.PUSHSTATE(XH)
        self.string = ''

    "{xqstart}":
        self.PUSHSTATE(XQ)
        self.string = ''

    "{dolqdelim}":
        self.PUSHSTATE(XDOLQ)
        self.dolqstart = self.value
        self.string = ''

    "{dolqfailed}":
        self.PUSHBACK(self.value[1:])
        return self.value[1]

    "{xdstart}":
        self.PUSHSTATE(XD)
        self.string = ''

    "{xuistart}":
        self.PUSHSTATE(XUI)
        self.string = ''

    "{xufailed}":
        self.PUSHBACK(self.value[1:])
        self.value = self.value[1:].lower()
        return 'IDENT'

    "{typecast}":
        return 'TYPECAST';

    "{self}":
        return self.value[0]

    "{operator}":
        nchars = len(self.value)
        slashstar = self.value[:2].find('/*')
        dashdash = self.value[:2].find('**')

        if slashstar != -1 and dashdash != -1:
            if slashstar > dashdash:
                slashstar = dashdash
        elif slashstar == -1:
            slashstar = dashdash

        if slashstar != -1:
            nchars = slashstar

        while nchars > 1 and (self.value[nchars - 1] == '+' or self.value[nchars - 1] == '-'):
            for ic in range(0, nchars - 2, -1):
                if self.value[ic] in "~!@#^&|`?%":
                    break

                if ic >= 0:
                    break
                nchars -= 1

        if nchars < len(self.value):
            self.PUSHBACK(self.value[nchars:])
            self.value = self.value[:nchars]

            if nchars == 1 and self.value[0] in ',()[].;:+-*/%^<>=':
                return self.value[0]

        return 'OP'

    "{param}":
        self.value = int(self.value[1:])
        return 'PARAM'

    "{integer}":
        self.value = int(self.value)
        return 'ICONST'

    "{decimal}":
        return 'FCONST'

    "{decimalfail}":
        self.PUSHBACK(self.value[-2:])
        self.value = int(self.value[:-2])
        return 'ICONST'

    "{real}":
        return 'FCONST'

    "{realfail1}":
        self.PUSHBACK(self.value[-1:])
        self.value = self.value[:-1]
        return 'FCONST'

    "{realfail2}":
        self.PUSHBACK(self.value[-2:])
        self.value = self.value[:-2]
        return 'FCONST'

    "{identifier}":
        kw = pg_keywords.get(self.value.lower())
        if kw:
            self.value = self.value.lower()
            return kw[0]
        else:
            return 'IDENT'

    "{other}":
        return self.value

XC:
    "{xcstart}":
        self.xcdepth += 1
        self.PUSHBACK(self.value[2:])

    "{xcstop}":
        if self.xcdepth <= 0:
            self.PUSHSTATE(INITIAL)
        else:
            self.xcdepth -= 1

    "{xcinside}":
        return

    "{op_chars}":
        return

    "\*+":
        return

    "<<EOF>>":
        raise PgSQLSyntaxError("unterminated /* comment", token=self.token, lineno=self.lineno)


XB:
    "{quotestop}|{quotefail}":
        self.PUSHBACK(self.value[1:])
        self.PUSHSTATE(INITIAL)
        self.value = self.string
        return 'BCONST'

    "{xbinside}":
        self.string += self.value

    "{quotecontinue}":
        return

    "<<EOF>>":
        raise PgSQLSyntaxError("unterminated bit string literal",
                               token=self.token, lineno=self.lineno)


XH:
    "{quotestop}|{quotefail}":
        self.PUSHBACK(self.value[1:])
        self.PUSHSTATE(INITIAL)
        self.value = self.string
        return 'XCONST'

    "{xhinside}":
        self.string += self.value

    "{quotecontinue}":
        return

    "<<EOF>>":
        raise PgSQLSyntaxError("unterminated hexadecial string literal",
                               token=self.token, lineno=self.lineno)


XQ:
    "{quotestop}|{quotefail}":
        self.PUSHBACK(self.value[1:])
        self.PUSHSTATE(INITIAL)
        self.value = self.string
        return 'SCONST'

    "{xqdouble}":
        self.string += "'"

    "{xqinside}":
        self.string += self.value

    "{quotecontinue}":
        return

    "<<EOF>>":
        raise PgSQLSyntaxError("unterminated quoted string literal",
                               token=self.token, lineno=self.lineno)


XDOLQ:
    "{dolqdelim}":
        if self.value == self.dolqstart:
            self.dolqstart = None
            self.PUSHSTATE(INITIAL)
            self.value = self.string
            return 'SCONST'
        else:
            self.string += self.value[:-1]
            self.PUSHBACK(self.value[-1])

    "{dolqinside}":
        self.string += self.value

    "{dolqfailed}":
        self.string += self.value

    ".":
        self.string += self.value

    "<<EOF>>":
        raise PgSQLSyntaxError("unterminated dollar-quoted string literal",
                               token=self.token, lineno=self.lineno)

XD:
    "{xdstop}":
        self.PUSHSTATE(INITIAL)
        if len(self.string) == 0:
            raise PgSQLSyntaxError("zero-length delimited identifier",
                                   token=self.token, lineno=self.lineno)

        self.value = self.string
        return 'IDENT'

    "{xddouble}":
        self.string += '"'

    "{xdinside}":
        self.string += self.value

    "<<EOF>>":
        raise PgSQLSyntaxError("unterminated quoted identifier",
                               token=self.token, lineno=self.lineno)


XUI:
    "{xuistop1}":
        self.PUSHSTATE(INITIAL)
        if len(self.string) == 0:
            raise PgSQLSyntaxError("zero-length delimited identifier",
                                   token=self.token, lineno=self.lineno)

        self.PUSHBACK(self.value[1:])

        self.value = self.string
        return 'IDENT'

    "{xuistop2}":
        self.PUSHSTATE(INITIAL)
        if len(self.string) == 0:
            raise PgSQLSyntaxError("zero-length delimited identifier",
                                   token=self.token, lineno=self.lineno)

        self.value = self.string
        return 'IDENT'

    "{xddouble}":
        self.string += '"'

    "{xdinside}":
        self.string += self.value

    "<<EOF>>":
        raise PgSQLSyntaxError("unterminated quoted identifier",
                               token=self.token, lineno=self.lineno)

